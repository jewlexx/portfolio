const puppeteer = require('puppeteer'); // v20.7.4 or later

(async () => {
	const browser = await puppeteer.launch({ headless: 'new' });
	const page = await browser.newPage();
	const timeout = 5000;
	page.setDefaultTimeout(timeout);

	{
		const targetPage = page;
		await targetPage.setViewport({
			width: 2025,
			height: 1271
		});
	}
	{
		const targetPage = page;
		await waitForElement(
			{
				type: 'waitForElement',
				target: 'main',
				selectors: ['#stars']
			},
			targetPage,
			timeout
		);
	}
	{
		const targetPage = page;
		const promises = [];
		const startWaitingForEvents = () => {
			promises.push(targetPage.waitForNavigation());
		};
		startWaitingForEvents();
		await targetPage.goto('https://www.jewelexx.com/');
		await Promise.all(promises);
	}
	{
		const targetPage = page;
		await puppeteer.Locator.race([
			targetPage.locator('::-p-aria(Projects[role=\\"heading\\"])'),
			targetPage.locator('a:nth-of-type(2) > h3'),
			targetPage.locator('::-p-xpath(/html/body/astro-island[2]/header/nav/a[2]/h3)'),
			targetPage.locator(':scope >>> a:nth-of-type(2) > h3'),
			targetPage.locator('::-p-text(Projects)')
		])
			.setTimeout(timeout)
			.click({
				offset: {
					x: 34.765625,
					y: 18.59375
				}
			});
	}
	{
		const targetPage = page;
		await puppeteer.Locator.race([
			targetPage.locator(
				'::-p-aria(ðŸ¤ Toy Project Exam Progress) >>>> ::-p-aria([role=\\"image\\"])'
			),
			targetPage.locator('li:nth-of-type(2) img'),
			targetPage.locator('::-p-xpath(/html/body/main/section/ul/li[2]/a/img)'),
			targetPage.locator(':scope >>> li:nth-of-type(2) img')
		])
			.setTimeout(timeout)
			.click({
				offset: {
					x: 516,
					y: 335.28125
				}
			});
	}
	{
		const targetPage = page;
		await waitForElement(
			{
				type: 'waitForElement',
				target: 'main',
				selectors: ['aria/Total Time (minutes):', '#time', 'xpath///*[@id="time"]', 'pierce/#time'],
				visible: true
			},
			targetPage,
			timeout
		);
	}
	{
		const targetPage = page;
		await puppeteer.Locator.race([
			targetPage.locator('::-p-aria(Projects[role=\\"heading\\"])'),
			targetPage.locator('a:nth-of-type(2) > h3'),
			targetPage.locator('::-p-xpath(/html/body/astro-island/header/nav/a[2]/h3)'),
			targetPage.locator(':scope >>> a:nth-of-type(2) > h3')
		])
			.setTimeout(timeout)
			.click({
				offset: {
					x: 56.671875,
					y: 11.59375
				}
			});
	}
	{
		const targetPage = page;
		await puppeteer.Locator.race([
			targetPage.locator(
				'::-p-aria(Stupid Fast Scoop Utils[role=\\"link\\"]) >>>> ::-p-aria([role=\\"image\\"])'
			),
			targetPage.locator('li:nth-of-type(1) img'),
			targetPage.locator('::-p-xpath(/html/body/main/section/ul/li[1]/a/img)'),
			targetPage.locator(':scope >>> li:nth-of-type(1) img')
		])
			.setTimeout(timeout)
			.click({
				offset: {
					x: 1107,
					y: 337.1875
				}
			});
	}
	{
		const targetPage = page;
		await waitForElement(
			{
				type: 'waitForElement',
				target: 'main',
				selectors: [
					'aria/GitHub all releases',
					'a:nth-of-type(3) > img',
					'xpath//html/body/main/article/div[2]/div/p/a[3]/img',
					'pierce/a:nth-of-type(3) > img'
				]
			},
			targetPage,
			timeout
		);
	}
	{
		const targetPage = page;
		await puppeteer.Locator.race([
			targetPage.locator('div.hero-image > img'),
			targetPage.locator('::-p-xpath(/html/body/main/article/div[1]/img)'),
			targetPage.locator(':scope >>> div.hero-image > img')
		])
			.setTimeout(timeout)
			.click({
				button: 'back',
				offset: {
					x: 822,
					y: 146.1875
				}
			});
	}
	{
		const targetPage = page;
		const promises = [];
		const startWaitingForEvents = () => {
			promises.push(targetPage.waitForNavigation());
		};
		startWaitingForEvents();
		await targetPage.goto('https://www.jewelexx.com/projects');
		await Promise.all(promises);
	}
	{
		const targetPage = page;
		await waitForElement(
			{
				type: 'waitForElement',
				target: 'main',
				selectors: [
					'aria/Stupid Fast Scoop Utils[role="heading"]',
					'li:nth-of-type(1) h4',
					'xpath//html/body/main/section/ul/li[1]/a/h4',
					'pierce/li:nth-of-type(1) h4',
					'text/Stupid Fast Scoop'
				]
			},
			targetPage,
			timeout
		);
	}
	{
		const targetPage = page;
		await puppeteer.Locator.race([
			targetPage.locator('::-p-aria(About[role=\\"heading\\"])'),
			targetPage.locator('a.false > h3'),
			targetPage.locator('::-p-xpath(/html/body/astro-island/header/nav/a[1]/h3)'),
			targetPage.locator(':scope >>> a.false > h3'),
			targetPage.locator('::-p-text(About)')
		])
			.setTimeout(timeout)
			.click({
				offset: {
					x: 27.53125,
					y: 8.59375
				}
			});
	}
	{
		const targetPage = page;
		await waitForElement(
			{
				type: 'waitForElement',
				target: 'main',
				selectors: [
					'p:nth-of-type(1)',
					'xpath//html/body/main/article/div[2]/p[1]',
					'pierce/p:nth-of-type(1)',
					'text/Iâ€™ll add something'
				]
			},
			targetPage,
			timeout
		);
	}
	{
		const targetPage = page;
		await puppeteer.Locator.race([
			targetPage.locator('::-p-aria(ðŸŒ)'),
			targetPage.locator('span.title-image > a'),
			targetPage.locator('::-p-xpath(/html/body/astro-island/header/nav/span[1]/a)'),
			targetPage.locator(':scope >>> span.title-image > a'),
			targetPage.locator('::-p-text(ðŸŒ)')
		])
			.setTimeout(timeout)
			.click({
				offset: {
					x: 33.4921875,
					y: 20.89375114440918
				}
			});
	}
	{
		const targetPage = page;
		await waitForElement(
			{
				type: 'waitForElement',
				target: 'main',
				selectors: [
					'aria/ðŸ§‘â€ðŸš€Hello, Traveller!',
					'h1',
					'xpath//html/body/main/div/h1',
					'pierce/h1',
					'text/ðŸ§‘â€ðŸš€Hello, Traveller!'
				],
				visible: true
			},
			targetPage,
			timeout
		);
	}

	await browser.close();

	async function waitForElement(step, frame, timeout) {
		const { count = 1, operator = '>=', visible = true, properties, attributes } = step;
		const compFn = {
			'==': (a, b) => a === b,
			'>=': (a, b) => a >= b,
			'<=': (a, b) => a <= b
		}[operator];
		await waitForFunction(async () => {
			const elements = await querySelectorsAll(step.selectors, frame);
			let result = compFn(elements.length, count);
			const elementsHandle = await frame.evaluateHandle(
				(...elements) => {
					return elements;
				},
				...elements
			);
			await Promise.all(elements.map((element) => element.dispose()));
			if (result && (properties || attributes)) {
				result = await elementsHandle.evaluate(
					(elements, properties, attributes) => {
						for (const element of elements) {
							if (attributes) {
								for (const [name, value] of Object.entries(attributes)) {
									if (element.getAttribute(name) !== value) {
										return false;
									}
								}
							}
							if (properties) {
								if (!isDeepMatch(properties, element)) {
									return false;
								}
							}
						}
						return true;

						function isDeepMatch(a, b) {
							if (a === b) {
								return true;
							}
							if ((a && !b) || (!a && b)) {
								return false;
							}
							if (!(a instanceof Object) || !(b instanceof Object)) {
								return false;
							}
							for (const [key, value] of Object.entries(a)) {
								if (!isDeepMatch(value, b[key])) {
									return false;
								}
							}
							return true;
						}
					},
					properties,
					attributes
				);
			}
			await elementsHandle.dispose();
			return result === visible;
		}, timeout);
	}

	async function querySelectorsAll(selectors, frame) {
		for (const selector of selectors) {
			const result = await querySelectorAll(selector, frame);
			if (result.length) {
				return result;
			}
		}
		return [];
	}

	async function querySelectorAll(selector, frame) {
		if (!Array.isArray(selector)) {
			selector = [selector];
		}
		if (!selector.length) {
			throw new Error('Empty selector provided to querySelectorAll');
		}
		let elements = [];
		for (let i = 0; i < selector.length; i++) {
			const part = selector[i];
			if (i === 0) {
				elements = await frame.$$(part);
			} else {
				const tmpElements = elements;
				elements = [];
				for (const el of tmpElements) {
					elements.push(...(await el.$$(part)));
				}
			}
			if (elements.length === 0) {
				return [];
			}
			if (i < selector.length - 1) {
				const tmpElements = [];
				for (const el of elements) {
					const newEl = (
						await el.evaluateHandle((el) => (el.shadowRoot ? el.shadowRoot : el))
					).asElement();
					if (newEl) {
						tmpElements.push(newEl);
					}
				}
				elements = tmpElements;
			}
		}
		return elements;
	}

	async function waitForFunction(fn, timeout) {
		let isActive = true;
		const timeoutId = setTimeout(() => {
			isActive = false;
		}, timeout);
		while (isActive) {
			const result = await fn();
			if (result) {
				clearTimeout(timeoutId);
				return;
			}
			await new Promise((resolve) => setTimeout(resolve, 100));
		}
		throw new Error('Timed out');
	}
})().catch((err) => {
	console.error(err);
	process.exit(1);
});
